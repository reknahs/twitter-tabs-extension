// current filter and configs
let CURRENT_FILTER = null;
let FILTER_CONFIG = null;

// listen to set new filters
window.addEventListener("message", (event) => {
  if (event.source !== window) return;

  if (event.data.type === "SET_FILTER") {
    CURRENT_FILTER = event.data.filter;
    FILTER_CONFIG = event.data.config;
  }
});

// only filter if user is on home/following timeline
function isOnHomeTimeline() {
  const path = window.location.pathname;
  return path === "/home" || path === "/";
}

// make sure we are only filtering tweets and not ads, etc.
function isContentEntry(entry) {
  return (
    entry.entryId?.startsWith("tweet-") ||
    entry.entryId?.startsWith("home-conversation-") ||
    entry.entryId?.startsWith("conversationthread-")
  );
}

//  XHR INTERCEPTION (intercept tweets generated by algorithm before they reach user)
const OriginalXHR = window.XMLHttpRequest;
const originalResponseTextGetter = Object.getOwnPropertyDescriptor(
  OriginalXHR.prototype,
  "responseText"
).get;
const originalResponseGetter = Object.getOwnPropertyDescriptor(
  OriginalXHR.prototype,
  "response"
).get;

// replace XMLHttpRequest with custom function
window.XMLHttpRequest = function () {
  const xhr = new OriginalXHR();
  const xhrState = {
    url: "",
    isTwitterAPI: false,
    filteredResponse: null,
    responseIntercepted: false,
  };

  const originalOpen = xhr.open;
  const originalSend = xhr.send;

  // intercept open() call to see Twitter's requested URL
  xhr.open = function (method, url, ...args) {
    xhrState.url = String(url);
    xhrState.isTwitterAPI = xhrState.url.includes("/graphql/");
    return originalOpen.call(this, method, url, ...args);
  };

  // intercept only if its a Twitter API request and
  xhr.send = function (...args) {
    // intercept only if its a Twitter API request and user on home/following timeline
    if (xhrState.isTwitterAPI && isOnHomeTimeline()) {
      Object.defineProperty(xhr, "responseText", {
        get: function () {
          const original = originalResponseTextGetter.call(xhr);

          // check that all data is available
          if (
            original &&
            xhr.readyState === 4 &&
            !xhrState.responseIntercepted
          ) {
            xhrState.responseIntercepted = true;

            try {
              const filtered = filterResponse(original);
              xhrState.filteredResponse =
                filtered !== original ? filtered : original;
            } catch (e) {
              console.error("Filter error:", e);
              xhrState.filteredResponse = original;
            }
          }

          return xhrState.filteredResponse || original;
        },
        configurable: true,
      });

      // same thing but if it's not necessarily a string
      Object.defineProperty(xhr, "response", {
        get: function () {
          if (
            xhrState.filteredResponse &&
            (xhr.responseType === "" || xhr.responseType === "text")
          ) {
            return xhrState.filteredResponse;
          }

          const original = originalResponseGetter.call(xhr);

          if (
            original &&
            xhr.readyState === 4 &&
            !xhrState.responseIntercepted
          ) {
            xhrState.responseIntercepted = true;

            try {
              const originalText =
                typeof original === "string"
                  ? original
                  : JSON.stringify(original);
              const filtered = filterResponse(originalText);

              if (filtered !== originalText) {
                xhrState.filteredResponse = filtered;
                return xhr.responseType === "json"
                  ? JSON.parse(filtered)
                  : filtered;
              }
            } catch (e) {
              console.error("âŒ Filter error:", e);
            }
          }

          return original;
        },
        configurable: true,
      });
    }

    // send the new request
    return originalSend.call(xhr, ...args);
  };

  return xhr;
};

// preserve prototype
window.XMLHttpRequest.prototype = OriginalXHR.prototype;

// FETCH INTERCEPTION
const originalFetch = window.fetch;

// use fetch to intercept
window.fetch = async function (resource, options) {
  const url = typeof resource === "string" ? resource : resource.url;
  const isTwitterAPI = url && url.includes("/graphql/");
  const response = await originalFetch.apply(this, arguments);

  if (!isTwitterAPI || !isOnHomeTimeline()) {
    return response;
  }

  const clonedResponse = response.clone();

  try {
    const originalText = await clonedResponse.text();
    const filteredText = filterResponse(originalText);

    if (filteredText !== originalText) {
      return new Response(filteredText, {
        status: response.status,
        statusText: response.statusText,
        headers: response.headers,
      });
    }
  } catch (e) {
    console.error("Fetch filter error:", e);
  }

  return response;
};

// keyword matching algorithm
function matchesFilter(text) {
  if (!FILTER_CONFIG) {
    return { matches: false, score: 0, matchedKeywords: [] };
  }

  let score = 0;
  const matchedKeywords = [];

  // check if tweet has any keywords
  for (const kw of FILTER_CONFIG.keywords || []) {
    if (text.includes(kw.toLowerCase())) {
      score += 1;
      matchedKeywords.push(kw);
    }
  }

  return {
    matches: score >= 1,
    score: score,
    matchedKeywords: matchedKeywords,
  };
}

// filtering logic
function filterResponse(responseText) {
  // early exit if not on home timeline, filter isn't selected, or config not loaded
  if (!isOnHomeTimeline() || !CURRENT_FILTER || !FILTER_CONFIG) {
    return responseText;
  }

  try {
    const data = JSON.parse(responseText);
    const instructions = findInstructions(data);

    if (!instructions) return responseText;

    // stat keeping
    let total = 0,
      kept = 0;

    instructions.forEach((inst) => {
      if (inst.type === "TimelineAddEntries" && inst.entries) {
        const filtered = [];

        inst.entries.forEach((entry) => {
          // keep cursors (needed for infinite scrolling)
          if (entry.entryId?.startsWith("cursor-")) {
            filtered.push(entry);
            return;
          }

          // keep nontweets (might get flagged by Twitter's anti adblock)
          if (!isContentEntry(entry)) {
            filtered.push(entry);
            return;
          }

          total++;
          const text = extractTextFromEntry(entry);

          // deleted tweets, empty, etc.
          if (!text) {
            filtered.push(entry);
            kept++;
            return;
          }

          const lowerText = text.toLowerCase();
          const keywordResult = matchesFilter(lowerText);

          if (keywordResult.matches) {
            filtered.push(entry);
            kept++;
          }
        });

        // ensure at least one content entry (otherwise, infinite scroll breaks)
        const contentEntries = filtered.filter(isContentEntry);

        if (contentEntries.length === 0 && inst.entries.length > 2) {
          const firstContent = inst.entries.find(isContentEntry);

          if (firstContent) {
            filtered.push(firstContent);
            kept++;
          }
        }

        // mutates original json object so Twitter DOM gets filtered one
        inst.entries = filtered;
      }
    });

    const removed = total - kept;

    // for debugging
    window.postMessage(
      {
        type: "FILTER_STATS",
        hasResults: kept > 0,
        total,
        kept,
        removed,
        filterName: FILTER_CONFIG.name,
      },
      "*"
    );

    return JSON.stringify(data);
  } catch (e) {
    // keep original unfiltered timeline if there are any errors
    console.error("Filter error:", e);
    return responseText;
  }
}

// get text from tweet
function extractTextFromEntry(entry) {
  // for threads (treats all tweets in the thread as one)
  if (
    entry.entryId?.startsWith("home-conversation-") ||
    entry.entryId?.startsWith("conversationthread-")
  ) {
    const items = entry.content?.items;
    if (!items?.length) return null;

    // include username in text to help w/ classification
    const texts = [];
    items.forEach((item) => {
      const result = item.item?.itemContent?.tweet_results?.result;
      const legacy = result?.legacy || result?.tweet?.legacy;
      if (!legacy) return;

      const user =
        result.core?.user_results?.result?.legacy?.screen_name ||
        result.tweet?.core?.user_results?.result?.legacy?.screen_name ||
        "";
      const text = legacy.full_text || "";

      if ((user + text).trim()) {
        texts.push(user + " " + text);
      }
    });

    return texts.join(" ");
  }

  // regular tweets
  try {
    const result = entry.content?.itemContent?.tweet_results?.result;
    const legacy = result?.legacy || result?.tweet?.legacy;
    if (!legacy) return null;

    const user =
      result.core?.user_results?.result?.legacy?.screen_name ||
      result.tweet?.core?.user_results?.result?.legacy?.screen_name ||
      "";
    const text = legacy.full_text || "";

    return user + " " + text;
  } catch (e) {
    return null;
  }
}

// get timeline data
function findInstructions(data) {
  const paths = [
    data?.data?.home?.home_timeline_urt?.instructions,
    data?.data?.home_timeline_urt?.instructions,
    data?.data?.user?.result?.timeline_v2?.timeline?.instructions,
  ];

  for (const path of paths) {
    if (path?.some?.((i) => i.type === "TimelineAddEntries")) {
      return path;
    }
  }

  // recursively searches for instructions array
  function search(obj, depth = 0) {
    if (depth > 6 || !obj || typeof obj !== "object") return null;

    if (Array.isArray(obj?.instructions)) {
      if (obj.instructions.some((i) => i.type === "TimelineAddEntries")) {
        return obj.instructions;
      }
    }

    for (const key in obj) {
      const result = search(obj[key], depth + 1);
      if (result) return result;
    }

    return null;
  }

  return data.data ? search(data.data) : null;
}
